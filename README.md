# Tamarin model for Core KEMTLS ("CoreKT")

This repository contains a Tamarin model for the "core cryptographic version" of the KEMTLS and KEMTLS-PDK protocol.  Roughly speaking, this means the version of KEMTLS as specified in Figures 3 and 7 of https://eprint.iacr.org/2020/534.pdf, and the version of KEMTLS-PDK as specified in https://eprint.iacr.org/2021/779.pdf, without any additional the framing from the TLS protocol, such as extra TLS message fields, pre-shared key / resumption, or handshake / application layer encryption.

The goal of this modelling exercise is to very closely follow the pen-and-paper security model and properties as specified in the multi-stage key exchange security model of the KEMTLS papers (https://eprint.iacr.org/2020/534.pdf and https://eprint.iacr.org/2021/779.pdf).

## Organization of the code base

The code base uses the M4 macro language to combine multiple source files into Tamarin files, as well as using macros to generate code and select different segments of code (M4 ifdef's).  The code base also uses Tamarin #ifdef's to selectively run different segments of code.

- `glossary.md` summarizes the primitives, state facts, and action facts used throughout the protocol, model, and lemmas.

- The `protocol` folder contains the formulation of the KEMTLS protocol in Tamarin.  In fact it includes four KEMTLS protocol modes: server-only authentication and mutual authentication from the original paper (https://eprint.iacr.org/2020/534.pdf), and server-only authentication and mutual authentication when server public keys are predistributed ("PDK mode") (https://eprint.iacr.org/2021/779.pdf).

- The `model` folder contains oracles that are accessible to the adversary for compromising secret keys.

- The `lemmas` folder contains lemmas modelling correctness and security properties.

	- `lemmas/reachable.spthy` contains lemmas that model correctness of the protocol. In particular, we want to check that it is possible to generate sessions and stages that achieve each of the intended states.
	- `lemmas/attacker_works.spthy` contains a few basic lemmas that check that it's possible for the attacker to trigger its various corruption queries.
	- `lemmas/match_security.spthy` contains lemmas that model "match security". This means the sound behaviour of session matching: that, for honest sessions, the session identifier matches the partnered session. This is a codification of Section B.4 and Definition B.1 of https://eprint.iacr.org/2020/534.pdf. Please see Section B.4 of the paper for references on the origin of modelling match security as a separate property for authenticated key exchange protocols.
	- `lemmas/sk_security.spthy` contains lemmas that model session key security. There are separate lemmas checking keys that are intended to have "weak forward secrecy 1", "weak forward secrecy 2", or "(full) forward secrecy".  This is a codification of the freshness conditions in Definition B.3 of https://eprint.iacr.org/2020/534.pdf.
	- `lemmas/malicious_acceptance.spthy` contains a lemma that models authentication security of KEMTLS: for session stages that believe they have authenticated their peer, there really is a matching session. This is a codification of Definition B.4 in https://eprint.iacr.org/2020/534.pdf.

- The `deniability` folder contains protocol specifications and lemmas for modelling offline deniability of KEMTLS via Tamarin's observational equivalence feature.  For each variant {sauth, mutual, pdk_sauth, pdk_mutual}:

	- `deniability/variant_real.spthy` contains a rule that generates the transcript using parties' secret keys to decapsulate.
	- `deniability/variant_simulated.spthy` contains a rule that generates the transcript using only parties' public keys.
	- `deniability/variant.spthy` contains a lemma checking that the transcripts generated by the `real` and `simulated` rules are indistinguishable.

- `corekt.spthy` uses m4 macros to pull all the above Tamarin source code (except deniability) into a single file.  Run the command `make preprocess` to generate the resulting file `generated_corekt.spthy`, which is the file you should actually have Tamarin run.

- The `output` folder contains output from having run the model.

## Getting started

1. You'll need to have a working version of [Tamarin prover](https://tamarin-prover.github.io) installed.
2. Run `make preprocess` to run the M4 preprocessor to generate various combined Tamarin files.

### To run deniability lemmas:

- Run `time make deniability-variant` or `time make deniability-variant-full`, for variant in {`sauth`, `mutual`, `pdk-sauth`, `pdk-mutual`} to check the offline deniability property for the given variant.  Without `-full`, some messages are omitted, and these take between 1 and 15 minutes each to run on a 16-core machine with 32 GB of RAM.  With `-full`, all messages are included, and these take between TODO and TODO minutes each to run on 16-cores of a large machine with 180 GB of RAM.  See the documentation in `deniability/kemtls_variant.spthy` for a more detailed explanation of the security property and message omission/inclusion.

### To run all other lemmas: (TODO: update documentation)

- Run `make prove` to have Tamarin try to prove all the above lemmas (except for deniability).  The output will be shown on the screen and stored in the `output` directory.  On a 16-core machine with lots of RAM, it takes about 7 minutes of wall clock time to prove all the lemmas (using Tamarin version 1.6.1).
	- You can prove a specific lemma with `make prove PROVE=sk_security_wfs1` (for example).
	- You can also use the Tamarin web UI: `tamarin-prover interactive .`

