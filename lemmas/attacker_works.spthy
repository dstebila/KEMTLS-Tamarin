/* This file contains a few basic lemmas that check that it's possible for the
 * attacker to trigger its various corruption queries.
 */

/* This lemma checks that it is possible for the attacker to trigger the RevealSK 
 * oracle.
 */
lemma attacker_works_revealsk:
  exists-trace
  "
    ∃ tid stage #t1
    .
    RevealedSessionKey(tid, stage) @ #t1
  "

/* This macro generates lemmas that check that it is possible for the attacker 
 * to trigger the CorrupeLTK oracle for each type of long-term key.
 */
dnl M_LEMMA_ATTACKER_WORKS_CORRUPTLTK
dnl arguments:
dnl $1: KEM type (KEM_c, KEM_s)
define(<!M_LEMMA_ATTACKER_WORKS_CORRUPTLTK!>,<!
lemma attacker_works_corruptltk_$1:
  exists-trace
  "
    ∃ P #t1
    .
    CorruptedLTK(P, '$1') @ #t1
  "
!>)

M_LEMMA_ATTACKER_WORKS_CORRUPTLTK(KEM_c)
M_LEMMA_ATTACKER_WORKS_CORRUPTLTK(KEM_s)
// There's no attacker_works_corruptltk_KEM_e lemma because KEM_e is for 
// ephemeral keys, not long-term keys, so the attacker can't corrupt them. 
// If you do generate a attacker_works_corruptltk_KEM_e, Tamarin should 
// (and does at the time I wrote this comment) fail to find a trace in which
// the attacker corrupts a KEM_e key.
dnl M_LEMMA_ATTACKER_WORKS_CORRUPTLTK(KEM_e) 
